<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Party Pixels · Highscores</title>
  <link rel="stylesheet" href="/pp-main.css" />

  <style>
    .pp-wrap { max-width: 980px; margin: 0 auto; padding: 22px 16px 64px; }
    .pp-row { display:flex; justify-content:space-between; align-items:baseline; gap:12px; flex-wrap:wrap; }
    .pp-h1 { font-size: 26px; margin: 10px 0 6px; }
    .pp-sub { color: var(--muted); margin: 0 0 18px; }

    .pp-card {
      border-radius: 18px;
      padding: 14px 14px 16px;
      background:
        radial-gradient(circle at top left, rgba(255, 92, 255, 0.12), transparent 55%),
        radial-gradient(circle at bottom right, rgba(92, 138, 255, 0.18), transparent 65%),
        rgba(7, 11, 32, 0.92);
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 18px 45px rgba(0,0,0,0.45);
    }

    .pp-back { font-size: 12px; color: var(--muted); text-decoration:none; border-bottom:1px dotted rgba(154,156,210,0.4); }
    .pp-back:hover { color: var(--text); }

    table.pp-table { width:100%; border-collapse: collapse; overflow:hidden; border-radius: 14px; }
    .pp-table thead { background: rgba(255,255,255,0.05); }
    .pp-table th, .pp-table td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 13px;
      white-space: nowrap;
    }
    .pp-table th { text-align:left; color: rgba(180,190,255,0.95); font-size: 11px; letter-spacing: .14em; text-transform: uppercase; }
    .pp-table th:nth-child(1), .pp-table td:nth-child(1) { width: 48px; text-align:center; }
    .pp-table th:nth-child(3), .pp-table td:nth-child(3) { text-align:right; }
    .pp-table th:nth-child(4), .pp-table td:nth-child(4) { text-align:right; }

    .pp-score { color: #fff2b7; font-variant-numeric: tabular-nums; }
    .pp-when { color: var(--muted); font-size: 12px; }

    .pp-you { background: linear-gradient(90deg, rgba(0,255,149,0.14), transparent); box-shadow: inset 2px 0 0 rgba(0,255,149,0.55); }
    .pp-you-badge {
      display:inline-flex; align-items:center; justify-content:center;
      margin-left: 8px; padding: 2px 8px; border-radius: 999px;
      font-size: 10px; letter-spacing: .16em; text-transform: uppercase;
      background: linear-gradient(90deg,#10b981,#22c55e); color:#04110a;
      box-shadow: 0 0 0 1px rgba(3,255,150,0.35);
    }

    .pp-status { margin-top: 10px; color: var(--muted); font-size: 12px; }
    .pp-status.err { color: #ffb4b4; }
  </style>
</head>

<body>
  <div class="page">
    <div id="header"></div>

    <main class="pp-wrap">
      <div class="pp-row">
        <a class="pp-back" id="ppBackLink" href="/index.html">← Back</a>
        <div></div>
      </div>

      <h1 class="pp-h1" id="ppTitle">Highscores</h1>
      <p class="pp-sub" id="ppSubtitle">Best runs from Party Pixels players.</p>

      <section class="pp-card">
        <table class="pp-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Player</th>
              <th id="ppScoreHead">Score</th>
              <th>When</th>
            </tr>
          </thead>
          <tbody id="ppBody">
            <tr><td colspan="4">Loading…</td></tr>
          </tbody>
        </table>

        <div class="pp-status" id="ppStatus">Loading…</div>
      </section>
    </main>

    <div id="footer"></div>
  </div>

  <!-- PARTS -->
  <script>
    function loadPart(id, file, cb) {
      fetch(file).then(r => r.text()).then(html => {
        const el = document.getElementById(id);
        if (el) el.innerHTML = html;
        if (typeof cb === "function") cb();
      }).catch(err => console.error("Load error:", file, err));
    }
    loadPart("header", "/header.html", () => {
      if (window.ppUpdateUserButton) window.ppUpdateUserButton();
    });
    loadPart("footer", "/footer.html");
  </script>

  <!-- Supabase + auth -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/pp-auth.js"></script>

  <script>
    const titleEl   = document.getElementById("ppTitle");
    const subEl     = document.getElementById("ppSubtitle");
    const bodyEl    = document.getElementById("ppBody");
    const statusEl  = document.getElementById("ppStatus");
    const backEl    = document.getElementById("ppBackLink");
    const scoreHead = document.getElementById("ppScoreHead");

    // per-toy defaults (fallback jeśli meta nie jest dostępne)
    const TOY_RULES = {
      "tap-to-survive":         { better: "max", unit: "s",  decimals: 1, scoreLabel: "Time (s)" },
      "reaction-speed-test":    { better: "min", unit: "ms", decimals: 0, scoreLabel: "Reaction (ms)" },
    };

    function fmtWhen(ts) {
      if (!ts) return "";
      const d = new Date(ts);
      if (isNaN(d.getTime())) return "";
      return d.toLocaleDateString(undefined, { year:"numeric", month:"short", day:"numeric" }) +
        " · " +
        d.toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
    }

    function escapeHtml(s) {
      return String(s ?? "").replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    function pickRules(toyId, maybeMeta) {
      const base = TOY_RULES[toyId] || { better:"max", unit:"score", decimals: 1, scoreLabel: "Score" };

      // jeśli w przyszłości meta zacznie dochodzić z bazy, to nadpisz:
      const better = (maybeMeta && (maybeMeta.better === "min" || maybeMeta.better === "max")) ? maybeMeta.better : base.better;
      const unit   = (maybeMeta && typeof maybeMeta.unit === "string" && maybeMeta.unit.trim()) ? maybeMeta.unit.trim() : base.unit;

      // heurystyka: ms zwykle bez miejsc po przecinku
      const decimals = (unit === "ms") ? 0 : base.decimals;

      const scoreLabel =
        (unit === "ms") ? "Reaction (ms)" :
        (unit === "s")  ? "Time (s)" :
        base.scoreLabel;

      return { better, unit, decimals, scoreLabel };
    }

    function formatScore(n, rules) {
      const num = Number(n);
      if (!isFinite(num)) return "—";
      return rules.decimals === 0 ? String(Math.round(num)) : num.toFixed(rules.decimals);
    }

    async function run() {
      const params = new URLSearchParams(location.search);
      const toyId = (params.get("toy") || "").trim();

      if (!toyId) {
        titleEl.textContent = "Highscores";
        subEl.textContent = "Missing ?toy=…";
        bodyEl.innerHTML = `<tr><td colspan="4">Missing toy id.</td></tr>`;
        statusEl.textContent = "Add ?toy=tap-to-survive or ?toy=reaction-speed-test";
        statusEl.classList.add("err");
        return;
      }

      // title + back link
      titleEl.textContent = `Highscores · ${toyId}`;
      backEl.href = `/${toyId}.html`;
      backEl.textContent = "← Back";

      const sb = window.ppSupabaseClient;
      if (!sb) {
        bodyEl.innerHTML = `<tr><td colspan="4">Auth client not ready.</td></tr>`;
        statusEl.textContent = "pp-auth.js / supabase not loaded.";
        statusEl.classList.add("err");
        return;
      }

      statusEl.textContent = "Loading…";

      // current user (optional) — only for YOU badge
      let currentUid = null;
      try {
        const { data } = await sb.auth.getUser();
        currentUid = data?.user?.id || null;
      } catch {}

      // load scores (IMPORTANT: if RLS blocks SELECT, you'll only see your own rows)
      const { data: rows, error } = await sb
        .from("toy_scores")
        .select("user_id, toy_id, score, meta, created_at")
        .eq("toy_id", toyId)
        .order("created_at", { ascending: false })
        .limit(1000);

      if (error) {
        console.error(error);
        bodyEl.innerHTML = `<tr><td colspan="4">Error loading highscores.</td></tr>`;
        statusEl.textContent = error.message || "Error.";
        statusEl.classList.add("err");
        return;
      }

      if (!rows || rows.length === 0) {
        bodyEl.innerHTML = `<tr><td colspan="4">No scores yet.</td></tr>`;
        statusEl.textContent = "No scores yet.";
        return;
      }

      // decide rules (use first row meta if present, else defaults by toy)
      const rules = pickRules(toyId, rows[0]?.meta || null);
      scoreHead.textContent = rules.scoreLabel;

      // best per user (min or max depending on rules.better)
      const bestByUser = new Map();
      for (const r of rows) {
        const uid = r.user_id;
        if (!uid) continue;

        const score = Number(r.score);
        if (!isFinite(score)) continue;

        if (!bestByUser.has(uid)) {
          bestByUser.set(uid, r);
          continue;
        }

        const prev = bestByUser.get(uid);
        const prevScore = Number(prev.score);

        const isBetter =
          (rules.better === "min") ? (score < prevScore) :
          (score > prevScore);

        if (isBetter) bestByUser.set(uid, r);
      }

      // sort leaderboard
      const best = Array.from(bestByUser.values()).sort((a, b) => {
        const A = Number(a.score), B = Number(b.score);
        return (rules.better === "min") ? (A - B) : (B - A);
      }).slice(0, 200);

      // load display names
      const userIds = best.map(r => r.user_id);

      // NOTE: jeśli profiles ma RLS "tylko swoje", tu też będzie pusto — trzeba policy / view
      const { data: profs, error: profErr } = await sb
        .from("profiles")
        .select("user_id, display_name")
        .in("user_id", userIds);

      if (profErr) console.warn("profiles select blocked:", profErr);

      const nameByUser = new Map((profs || []).map(p => [p.user_id, (p.display_name || "Player")]));

      bodyEl.innerHTML = "";
      best.forEach((r, idx) => {
        const rank = idx + 1;
        const name = nameByUser.get(r.user_id) || "Player";
        const isYou = currentUid && r.user_id === currentUid;

        const tr = document.createElement("tr");
        if (isYou) tr.classList.add("pp-you");

        tr.innerHTML = `
          <td>${rank}</td>
          <td>
            ${escapeHtml(name)}
            ${isYou ? `<span class="pp-you-badge">YOU</span>` : ""}
          </td>
          <td class="pp-score">${escapeHtml(formatScore(r.score, rules))}</td>
          <td class="pp-when">${escapeHtml(fmtWhen(r.created_at))}</td>
        `;
        bodyEl.appendChild(tr);
      });

      // if RLS is blocking, you'll usually end up with only 1 user in bestByUser (you)
      const usersShown = best.length;
      statusEl.textContent =
        `Showing best run per player · ${usersShown} player${usersShown === 1 ? "" : "s"} · better = ${rules.better.toUpperCase()}.`;

      if (usersShown <= 1) {
        statusEl.classList.add("err");
        statusEl.textContent += " If you expected more: your Supabase RLS likely blocks reading other users’ scores.";
      }
    }

    document.addEventListener("DOMContentLoaded", run);
  </script>
</body>
</html>
